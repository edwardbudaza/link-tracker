src/repositories/UrlRepository.ts

// src/repositories/UrlRepository.ts

import { IUrlRepository } from "../interfaces/repositories/IUrlRepository";
import UrlModel, { Url } from "../models/Url";
import { injectable } from "inversify";
import { logger } from "../config/logger";

@injectable()
export class UrlRepository implements IUrlRepository {
  private readonly logger = logger;

  async create(url: Partial<Url>): Promise<Url> {
    const newUrl = new UrlModel(url);
    return await newUrl.save();
  }

  async findByShortId(shortId: string): Promise<Url | null> {
    return await UrlModel.findOne({ shortId, isActive: true });
  }

  async findByOriginalUrl(originalUrl: string): Promise<Url | null> {
    return await UrlModel.findOne({ originalUrl, isActive: true });
  }

  async updateById(id: string, url: Partial<Url>): Promise<Url | null> {
    return await UrlModel.findByIdAndUpdate(id, url, { new: true });
  }

  async delete(id: string): Promise<boolean> {
    const result = await UrlModel.findByIdAndUpdate(id, { isActive: false });
    return !!result;
  }

  async findByUserId(
    userId: string, 
    options?: { skip?: number; limit?: number }
  ): Promise<Url[]> {
    try {
      const query = UrlModel.find({ creator: userId });
      
      if (options?.skip !== undefined) {
        query.skip(options.skip);
      }
      
      if (options?.limit !== undefined) {
        query.limit(options.limit);
      }
      
      // Sort by creation date descending (newest first)
      query.sort({ createdAt: -1 });
      
      return await query.exec();
    } catch (error) {
      this.logger.error("Error finding URLs by user ID", { error: (error as Error).message, stack: (error as Error).stack });
      return [];
    }
  }

  async countByUserId(userId: string): Promise<number> {
    try {
      return await UrlModel.countDocuments({ creator: userId });
    } catch (error) {
      this.logger.error("Error counting URLs by user ID", { error: (error as Error).message, stack: (error as Error).stack });
      return 0;
    }
  }
}
src/repositories/UserRepository.ts

// src/repositories/UserRepository.ts

import { injectable } from "inversify";
import UserModel, { User } from "../models/User";
import { IUserRepository } from "../interfaces/repositories/IUserRepository";

@injectable()
export class UserRepository implements IUserRepository {
  async findByEmail(email: string): Promise<User | null> {
    return await UserModel.findOne({ email });
  }

  async findById(id: string): Promise<User | null> {
    return UserModel.findById(id);
  }

  async create(user: Partial<User>): Promise<User> {
    const newUser = new UserModel(user);
    return await newUser.save();
  }

  async updateById(id: string, updates: Partial<User>): Promise<User | null> {
    return await UserModel.findByIdAndUpdate(id, updates, { new: true });
  }
}
src/repositories/AnalyticsRepository.ts

// src/repositories/AnalyticsRepository.ts

import { timeStamp } from "console";
import { IAnalyticsRepository } from "../interfaces/repositories/IAnalyticsRepository";
import ClickEventModel, { ClickEvent } from "../models/ClickEvent";
import UrlModel from "../models/Url";
import { injectable } from "inversify";

@injectable()
export class AnalyticsRepository implements IAnalyticsRepository {
  async createClickEvent(clickEvent: Partial<ClickEvent>): Promise<ClickEvent> {
    const newClickEvent = new ClickEventModel(clickEvent);
    return await newClickEvent.save();
  }

  async getClicksByUrlId(urlId: string): Promise<ClickEvent[]> {
    return await ClickEventModel.find({ urlId }).sort({ timestamp: -1 });
  }

  async getClicksByDateRange(
    startDate: Date,
    endDate: Date
  ): Promise<ClickEvent[]> {
    return await ClickEventModel.find({
      timestamp: {
        $gte: startDate,
        $lte: endDate,
      },
    }).sort({ timestamp: -1 });
  }

  async getTopClicks(
    limit: number
  ): Promise<{ url: string; clicks: number }[]> {
    const result = await UrlModel.aggregate([
      { $match: { isActive: true } },
      { $sort: { clicks: -1 } },
      { $limit: limit },
      { $project: { _id: 0, originalUrl: 1, shortId: 1, clicks: 1 } },
    ]);

    return result.map((item) => ({
      url: item.originalUrl,
      shortId: item.shortId,
      clicks: item.clicks,
    }));
  }
}
src/errors/AuthError.ts

// src/errors/AuthError.ts

export type AuthErrorCode =
  | 'INVALID_CREDENTIALS'
  | 'INVALID_TOKEN'
  | 'TOKEN_EXPIRED'
  | 'USER_NOT_FOUND'
  | 'DUPLICATE_USER'
  | 'UNAUTHORIZED'
  | 'FORBIDDEN';

export class AuthError extends Error {
  constructor(
    message: string,
    public readonly code: AuthErrorCode,
    public readonly statusCode: number = 401
  ) {
    super(message);
    this.name = 'AuthError';
    Object.setPrototypeOf(this, AuthError.prototype);
  }

  static unauthorized(message: string = 'Unauthorized'): AuthError {
    return new AuthError(message, 'UNAUTHORIZED', 401);
  }

  static forbidden(message: string = 'Forbidden'): AuthError {
    return new AuthError(message, 'FORBIDDEN', 403);
  }

  static invalidCredentials(message: string = 'Invalid credentials'): AuthError {
    return new AuthError(message, 'INVALID_CREDENTIALS', 401);
  }

  static invalidToken(message: string = 'Invalid token'): AuthError {
    return new AuthError(message, 'INVALID_TOKEN', 401);
  }

  static tokenExpired(message: string = 'Token expired'): AuthError {
    return new AuthError(message, 'TOKEN_EXPIRED', 401);
  }

  static userNotFound(message: string = 'User not found'): AuthError {
    return new AuthError(message, 'USER_NOT_FOUND', 404);
  }

  static duplicateUser(message: string = 'User already exists'): AuthError {
    return new AuthError(message, 'DUPLICATE_USER', 409);
  }
} src/services/HtmlProcessorService.ts

// src/services/HtmlProcessorService.ts

import { injectable, inject } from "inversify";
import { JSDOM } from "jsdom";
import { IHtmlProcessorService } from "../interfaces/services/IHtmlProcessorService";
import { IUrlShortenerService } from "../interfaces/services/IUrlShortenerService";
import { ILoggingService } from "../interfaces/services/ILoggingService";
import { isValidUrl } from "../utils/urlGenerator";
import { APP_CONFIG } from "../config/app";
import { TYPES } from "../di/types";

@injectable()
export class HtmlProcessorService implements IHtmlProcessorService {
  constructor(
    @inject(TYPES.UrlShortenerService)
    private urlShortenerService: IUrlShortenerService,
    @inject(TYPES.LoggingService) private logger: ILoggingService
  ) {}

  extractUrls(html: string): string[] {
    try {
      const dom = new JSDOM(html);
      const document = dom.window.document;
      const anchorTags = document.querySelectorAll("a");

      // Extract and filter valid URLs
      const urls: string[] = [];
      anchorTags.forEach((anchor) => {
        const href = anchor.getAttribute("href");
        if (href && isValidUrl(href)) {
          urls.push(href);
        }
      });

      return [...new Set(urls)]; // Remove duplicates
    } catch (error) {
      this.logger.error("Error extracting URLs from HTML", error as Error);
      return [];
    }
  }

  async processHtml(
    html: string,
    baseUrl: string = APP_CONFIG.baseUrl
  ): Promise<string> {
    try {
      const dom = new JSDOM(html);
      const document = dom.window.document;
      const anchorTags = document.querySelectorAll("a");

      // Process each anchor tag
      const processPromises = Array.from(anchorTags).map(async (anchor) => {
        const href = anchor.getAttribute("href");

        // Skip if href is empty or not a valid URL
        if (!href || !isValidUrl(href)) {
          return;
        }

        try {
          // Shorten the URL
          const shortenedUrl = await this.urlShortenerService.shortenUrl(href);

          // Replace the href with the shortened URL
          const trackableUrl = `${baseUrl}/${shortenedUrl.shortId}`;
          anchor.setAttribute("href", trackableUrl);

          // Add data attribute for tracking
          anchor.setAttribute("data-original-url", href);
        } catch (error) {
          this.logger.error(
            "Error shortening URL during HTML processing",
            error as Error,
            { href }
          );
        }
      });

      // Wait for all anchor tags to be processed
      await Promise.all(processPromises);

      return dom.serialize();
    } catch (error) {
      this.logger.error("Error processing HTML", error as Error);
      throw error;
    }
  }
}
src/services/userService.ts

// src/services/userService.ts

import { injectable, inject } from 'inversify';
import { TYPES } from '../di/types';
import { IUserRepository } from '../interfaces/repositories/IUserRepository';
import { User } from '../models/User';
import bcrypt from 'bcrypt';

@injectable()
export class UserService {
  constructor(
    @inject(TYPES.UserRepository) private userRepository: IUserRepository
  ) {}

  async createUser(email: string, password: string, name?: string): Promise<User> {
    const hashedPassword = await bcrypt.hash(password, 10);
    return this.userRepository.create({
      email,
      password: hashedPassword,
      name,
      role: 'user'
    });
  }

  async findUserByEmail(email: string): Promise<User | null> {
    return this.userRepository.findByEmail(email);
  }

  async validatePassword(user: User, password: string): Promise<boolean> {
    return bcrypt.compare(password, user.password);
  }

  async updateUser(userId: string, updates: Partial<User>): Promise<User | null> {
    return this.userRepository.updateById(userId, updates);
  }
} src/services/UrlShortenerService.ts

// src/services/UrlShortenerService.ts

import { injectable, inject } from "inversify";
import { IUrlShortenerService } from "../interfaces/services/IUrlShortenerService";
import { IUrlRepository } from "../interfaces/repositories/IUrlRepository";
import { ILoggingService } from "../interfaces/services/ILoggingService";
import { generateShortId, isValidUrl } from "../utils/urlGenerator";
import { Url } from "../models/Url";
import { getRedisClient } from "../config/redis";
import { REDIS_CONFIG } from "../config/redis";
import { TYPES } from "../di/types";

@injectable()
export class UrlShortenerService implements IUrlShortenerService {
  constructor(
    @inject(TYPES.UrlRepository) private urlRepository: IUrlRepository,
    @inject(TYPES.LoggingService) private logger: ILoggingService
  ) {}

  async shortenUrl(originalUrl: string, customSlug?: string): Promise<Url> {
    if (!isValidUrl(originalUrl)) {
      throw new Error("Invalid URL format");
    }

    // Check if URL already exists in the database
    const existingUrl = await this.urlRepository.findByOriginalUrl(originalUrl);
    if (existingUrl && !customSlug) {
      return existingUrl;
    }

    // Generate a short ID or use custom slug
    const shortId = customSlug || generateShortId();

    // Check if custom slug is already in use
    if (customSlug) {
      const existingSlug = await this.urlRepository.findByShortId(customSlug);
      if (existingSlug) {
        throw new Error("Custom slug already in use");
      }
    }

    // Create new URL entry
    const newUrl = await this.urlRepository.create({
      originalUrl,
      shortId,
      customSlug: customSlug || undefined,
      createdAt: new Date(),
      clicks: 0,
      isActive: true,
    });

    this.logger.info("URL shortened successfully", {
      originalUrl,
      shortId,
      customSlug: customSlug || undefined,
    });

    return newUrl;
  }

  async getOriginalUrl(shortId: string): Promise<string | null> {
    try {
      // Try to get from Redis cache first
      const redisClient = await getRedisClient();
      if (redisClient) {
        try {
          const cachedUrl = await redisClient.get(`url:${shortId}`);
          if (cachedUrl) {
            this.logger.debug("URL retrieved from cache", { shortId });
            return cachedUrl;
          }
        } catch (error) {
          // Handle cache error gracefully
          const cacheError = error as Error;
          this.logger.warn("Error retrieving from cache", cacheError);
        }
      }

      // If not in cache or cache error, get from database
      const url = await this.urlRepository.findByShortId(shortId);

      if (!url) {
        this.logger.warn("URL not found", { shortId });
        return null;
      }

      // Update click count
      await this.urlRepository.updateById(url._id as unknown as string, {
        clicks: url.clicks + 1,
      });

      // Cache the result for future requests if Redis is available
      if (redisClient) {
        try {
          await redisClient.set(`url:${shortId}`, url.originalUrl, {
            EX: REDIS_CONFIG.ttl,
          });
        } catch (error) {
          const cacheError = error as Error;
          this.logger.warn("Error setting cache", cacheError);
        }
      }

      return url.originalUrl;
    } catch (error) {
      this.logger.error("Error retrieving original URL", error as Error, {
        shortId,
      });
      throw error;
    }
  }
}
src/services/RedirectionService.ts

// src/services/RedirectionService.ts

import { injectable, inject } from "inversify";
import { Request, Response, NextFunction } from "express";
import { IRedirectionService } from "../interfaces/services/IRedirectionService";
import { IUrlShortenerService } from "../interfaces/services/IUrlShortenerService";
import { IAnalyticsRepository } from "../interfaces/repositories/IAnalyticsRepository";
import { ILoggingService } from "../interfaces/services/ILoggingService";
import { parseUserAgent, getClientIp } from "../utils/userAgentParser";
import { TYPES } from "../di/types";

@injectable()
export class RedirectionService implements IRedirectionService {
  constructor(
    @inject(TYPES.UrlShortenerService)
    private urlShortenerService: IUrlShortenerService,
    @inject(TYPES.AnalyticsRepository)
    private analyticsRepository: IAnalyticsRepository,
    @inject(TYPES.LoggingService) private logger: ILoggingService
  ) {}

  async redirect(req: Request, res: Response, next: NextFunction): Promise<void> {
    const shortId = req.params.shortId;

    try {
      const originalUrl = await this.urlShortenerService.getOriginalUrl(shortId);

      if (!originalUrl) {
        res.status(404).json({
          success: false,
          message: "URL not found"
        });
        return;
      }

      // Track click analytics
      try {
        const userAgentInfo = parseUserAgent(req);
        const ipAddress = getClientIp(req);
        const referrer = req.headers.referer || "";

        // Track the click asynchronously - don't wait for it to complete
        this.analyticsRepository.createClickEvent({
          urlId: shortId,
          timestamp: new Date(),
          ipAddress,
          userAgent: req.headers["user-agent"],
          referrer,
          browser: userAgentInfo.browser,
          deviceType: userAgentInfo.device,
          os: userAgentInfo.os,
        }).catch(err => {
          this.logger.error("Failed to track click event", err);
        });
      } catch (analyticsError) {
        // Log the error but don't prevent redirection
        this.logger.error("Error tracking click", analyticsError as Error);
      }

      // Redirect to the original URL
      res.redirect(originalUrl);
    } catch (error) {
      this.logger.error("Redirection error", error as Error);
      next(error);
    }
  }

  async recordClickEvent(shortId: string, req: Request): Promise<void> {
    try {
      const userAgentInfo = parseUserAgent(req);
      const ipAddress = getClientIp(req);
      const referrer = req.headers.referer || "";

      await this.analyticsRepository.createClickEvent({
        urlId: shortId,
        timestamp: new Date(),
        ipAddress,
        userAgent: req.headers["user-agent"],
        referrer,
        browser: userAgentInfo.browser,
        deviceType: userAgentInfo.device,
        os: userAgentInfo.os,
      });
    } catch (error) {
      this.logger.error("Failed to record click event", error as Error);
      throw error;
    }
  }
}
src/services/authService.ts

// src/services/authService.ts

import jwt from 'jsonwebtoken';
import { APP_CONFIG } from '../config/app';
import UserModel, { User } from '../models/User';
import { generateApiKey } from '../utils/apiKey';
import { injectable, inject } from 'inversify';
import { IAuthService } from '../interfaces/services/IAuthService';
import { IUserRepository } from '../interfaces/repositories/IUserRepository';
import { ILoggingService } from '../interfaces/services/ILoggingService';
import { TYPES } from '../di/types';
import { AuthTokens } from '../interfaces/auth/tokens';
import 'reflect-metadata';
import bcrypt from 'bcrypt';
import { AuthError } from '../errors/AuthError';

type TokenPayload = {
  userId: string;
  email: string;
  role: string;
};

@injectable()
export class AuthService implements IAuthService {
  private readonly JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';
  private readonly ACCESS_TOKEN_EXPIRY = '1h';
  private readonly REFRESH_TOKEN_EXPIRY = '7d';
  private readonly refreshTokens = new Set<string>();

  constructor(
    @inject(TYPES.UserRepository) private userRepository: IUserRepository,
    @inject(TYPES.LoggingService) private logger: ILoggingService
  ) {}

  async registerUser(email: string, password: string, name?: string): Promise<User> {
    try {
      console.log('AuthService: Checking for existing user:', email);
      const existingUser = await UserModel.findOne({ email });
      if (existingUser) {
        console.log('AuthService: User already exists');
        throw AuthError.duplicateUser();
      }

      console.log('AuthService: Creating new user with:', { email, name });
      const user = await UserModel.create({
        email,
        password,
        name,
        role: 'user',
        active: true
      });

      console.log('AuthService: User created successfully:', { userId: user._id });
      // Generate tokens but only return the user as per interface
      this.generateTokens(user);
      return user;
    } catch (error) {
      console.error('AuthService: Registration error details:', {
        name: error instanceof Error ? error.name : 'Unknown error',
        message: error instanceof Error ? error.message : 'An unknown error occurred',
        stack: error instanceof Error ? error.stack : undefined
      });
      this.logger.error('Registration failed', error instanceof Error ? error : new Error('Unknown error'));
      throw error;
    }
  }

  async loginUser(email: string, password: string): Promise<{ user: User; tokens: AuthTokens }> {
    try {
      console.log('AuthService: Attempting login for:', email);
      const user = await UserModel.findOne({ email });
      if (!user) {
        console.log('AuthService: User not found');
        throw AuthError.invalidCredentials();
      }

      console.log('AuthService: User found, comparing passwords');
      const isValidPassword = await bcrypt.compare(password, user.password);
      if (!isValidPassword) {
        console.log('AuthService: Invalid password');
        throw AuthError.invalidCredentials();
      }

      console.log('AuthService: Password valid, generating tokens');
      const tokens = this.generateTokens(user);
      return { user, tokens };
    } catch (error) {
      console.error('AuthService: Login error:', error);
      this.logger.error('Login failed', error as Error);
      throw error;
    }
  }

  async refreshToken(refreshToken: string): Promise<AuthTokens> {
    try {
      if (!this.refreshTokens.has(refreshToken)) {
        throw AuthError.invalidToken();
      }

      const decoded = jwt.verify(refreshToken, this.JWT_SECRET) as { userId: string };
      const user = await UserModel.findById(decoded.userId);
      
      if (!user) {
        throw AuthError.userNotFound();
      }

      this.refreshTokens.delete(refreshToken);
      return this.generateTokens(user);
    } catch (error) {
      this.logger.error('Token refresh failed', error as Error);
      throw error;
    }
  }

  async logout(refreshToken: string): Promise<void> {
    this.refreshTokens.delete(refreshToken);
  }

  async refreshApiKey(userId: string): Promise<string> {
    try {
      const user = await UserModel.findById(userId);
      if (!user) {
        throw AuthError.userNotFound();
      }

      const newApiKey = generateApiKey();
      user.apiKey = newApiKey;
      await user.save();

      return newApiKey;
    } catch (error) {
      this.logger.error('API key refresh failed', error as Error);
      throw error;
    }
  }

  verifyToken(token: string): TokenPayload {
    try {
      const decoded = jwt.verify(token, this.JWT_SECRET);
      if (typeof decoded === 'string' || !this.isTokenPayload(decoded)) {
        throw AuthError.invalidToken();
      }
      return decoded;
    } catch (error) {
      throw AuthError.invalidToken();
    }
  }

  private generateTokens(user: User): AuthTokens {
    const accessToken = jwt.sign(
      { userId: user._id, email: user.email, role: user.role },
      this.JWT_SECRET,
      { expiresIn: this.ACCESS_TOKEN_EXPIRY }
    );

    const refreshToken = jwt.sign(
      { userId: user._id },
      this.JWT_SECRET,
      { expiresIn: this.REFRESH_TOKEN_EXPIRY }
    );

    this.refreshTokens.add(refreshToken);

    return {
      accessToken,
      refreshToken,
      expiresIn: this.getExpirationSeconds(this.ACCESS_TOKEN_EXPIRY)
    };
  }

  private getExpirationSeconds(expiresIn: string): number {
    const match = expiresIn.match(/^(\d+)([hmd])$/);
    if (!match) return 3600;

    const [, value, unit] = match;
    const multipliers: { [key: string]: number } = { h: 3600, m: 60, d: 86400 };
    return parseInt(value) * (multipliers[unit] || 3600);
  }

  private isTokenPayload(decoded: unknown): decoded is TokenPayload {
    return (
      typeof decoded === 'object' &&
      decoded !== null &&
      'userId' in decoded &&
      'email' in decoded &&
      'role' in decoded &&
      typeof (decoded as TokenPayload).userId === 'string' &&
      typeof (decoded as TokenPayload).email === 'string' &&
      typeof (decoded as TokenPayload).role === 'string'
    );
  }
} src/services/LoggingService.ts

// src/services/LoggingService.ts

import { injectable } from "inversify";
import {
  ILoggingService,
  LogContext,
} from "../interfaces/services/ILoggingService";
import { logger } from "../config/logger";

@injectable()
export class LoggingService implements ILoggingService {
  info(message: string, context?: LogContext): void {
    logger.info(message, { ...context });
  }

  error(message: string, error?: Error, context?: LogContext): void {
    logger.error(message, { error: error?.stack, ...context });
  }

  warn(message: string, context?: LogContext): void {
    logger.warn(message, { ...context });
  }

  debug(message: string, context?: LogContext): void {
    logger.debug(message, { ...context });
  }
}
src/services/tokenService.ts

// src/services/tokenService.ts

import { injectable } from 'inversify';
import jwt, { SignOptions, JwtPayload } from 'jsonwebtoken';
import { APP_CONFIG } from '../config/app';

@injectable()
export class TokenService {
  generateToken(payload: Record<string, any>): string {
    if (!APP_CONFIG.jwtSecret) {
      throw new Error('JWT secret is not configured');
    }
    const options: SignOptions = {
      expiresIn: Number(APP_CONFIG.jwtExpiresIn) || '1h'
    };
    return jwt.sign(payload, APP_CONFIG.jwtSecret, options);
  }

  verifyToken(token: string): JwtPayload {
    if (!APP_CONFIG.jwtSecret) {
      throw new Error('JWT secret is not configured');
    }
    const decoded = jwt.verify(token, APP_CONFIG.jwtSecret);
    return decoded as JwtPayload;
  }

  generateRefreshToken(userId: string): string {
    if (!APP_CONFIG.jwtSecret) {
      throw new Error('JWT secret is not configured');
    }
    const options: SignOptions = {
      expiresIn: '7d' // Refresh tokens last longer
    };
    return jwt.sign({ userId }, APP_CONFIG.jwtSecret, options);
  }
} src/utils/tokenUtils.ts

// src/utils/tokenUtils.ts

import jwt from "jsonwebtoken";
import { AUTH_CONFIG } from "../config/auth";
import { User } from "../models/User";

/**
 * Create an access token for authenticated users
 */
export const createAccessToken = (user: User): string => {
  return jwt.sign(
    {
      id: user.id,
      email: user.email,
      role: user.role,
    },
    AUTH_CONFIG.JWT_SECRET,
    { expiresIn: AUTH_CONFIG.JWT_EXPIRATION }
  );
};

/**
 * Create a refresh token for extending sessions
 */
export const createRefreshToken = (user: User): string => {
  return jwt.sign(
    {
      id: user.id,
    },
    AUTH_CONFIG.JWT_REFRESH_SECRET,
    { expiresIn: AUTH_CONFIG.JWT_REFRESH_EXPIRATION }
  );
};

/**
 * Verify an access token
 */
export const verifyAccessToken = (token: string): jwt.JwtPayload => {
  return jwt.verify(token, AUTH_CONFIG.JWT_SECRET) as jwt.JwtPayload;
};

/**
 * Verify a refresh token
 */
export const verifyRefreshToken = (token: string): jwt.JwtPayload => {
  return jwt.verify(token, AUTH_CONFIG.JWT_REFRESH_SECRET) as jwt.JwtPayload;
}; src/utils/urlGenerator.ts

// src/utils/urlGenerator.ts

import { customAlphabet } from "nanoid";

// Define an alphabet without ambiguous characters
const alphabet = "23456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

// Create a URL-safe ID generator
export const generateShortId = (length: number = 7): string => {
  const nanoid = customAlphabet(alphabet, length);
  return nanoid();
};

// Validate URL format
export const isValidUrl = (url: string): boolean => {
  try {
    new URL(url);
    return true;
  } catch (error) {
    return false;
  }
};
src/utils/apiKey.ts

// src/utils/apiKey.ts

import crypto from 'crypto';

export const generateApiKey = (): string => {
  return `lk_${crypto.randomBytes(32).toString('hex')}`;
}; src/utils/userAgentParser.ts

// src/utils/userAgentParser.ts

import { UAParser } from "ua-parser-js";
import { Request } from "express";

export interface UserAgentInfo {
  browser: string;
  browserVersion: string;
  os: string;
  osVersion: string;
  device: string;
  isMobile: boolean;
  isTablet: boolean;
  isDesktop: boolean;
}

export const parseUserAgent = (req: Request): UserAgentInfo => {
  const userAgentString = req.headers["user-agent"] || "";
  const parser = new UAParser(); // Create an instance
  parser.setUA(userAgentString); // Set the user agent
  const result = parser.getResult(); // Get parsed data

  const device =
    result.device.type ||
    (result.device.vendor
      ? `${result.device.vendor} ${result.device.model}`
      : "unknown");
  const isMobile = result.device.type === "mobile";
  const isTablet = result.device.type === "tablet";
  const isDesktop = !isMobile && !isTablet;

  return {
    browser: result.browser.name || "unknown",
    browserVersion: result.browser.version || "unknown",
    os: result.os.name || "unknown",
    osVersion: result.os.version || "unknown",
    device,
    isMobile,
    isTablet,
    isDesktop,
  };
};

// Get client IP address from request
export const getClientIp = (req: Request): string => {
  return (
    (req.headers["x-forwarded-for"] as string)?.split(",")[0] ||
    req.socket.remoteAddress ||
    ""
  );
};
src/app.ts

// src/app.ts

import express, { Application } from "express";
import helmet from "helmet";
import cors from "cors";
import compression from "compression";
import swaggerUi from "swagger-ui-express";
import { APP_CONFIG } from "./config/app";
import { connectDB } from "./config/database";
import { logger } from "./config/logger";
import { errorHandler } from "./middlewares/errorHandler";
import { requestLogger } from "./middlewares/requestLogger";
import { container } from "./di/container";
import { TYPES } from "./di/types";
import { IAuthController } from "./interfaces/controllers/IAuthController";
import { IUrlController } from "./interfaces/controllers/IUrlController";
import { IAnalyticsController } from "./interfaces/controllers/IAnalyticsController";
import { IRedirectController } from "./interfaces/controllers/IRedirectController";
import { authMiddleware } from "./middlewares/authMiddleware";

// Import swagger document
const swaggerDocument = require("../swagger.json");

// Import routes
import urlRoutes from "./routes/urlRoutes";
import redirectRoutes from "./routes/redirectRoutes";
import analyticsRoutes from "./routes/analyticsRoutes";
import authRoutes from "./routes/authRoutes";

class App {
  public app: Application;

  constructor() {
    this.app = express();
    this.initializeMiddlewares();
    this.initializeRoutes();
    this.initializeErrorHandling();
  }

  private initializeMiddlewares(): void {
    // Security
    this.app.use(helmet({
      contentSecurityPolicy: false // Allow Swagger UI to load scripts and styles
    }));

    // CORS
    this.app.use(cors());

    // Compression
    this.app.use(compression());

    // Body parser
    this.app.use(express.json());
    this.app.use(express.urlencoded({ extended: true }));

    // Request logging
    this.app.use(requestLogger);

    // Swagger documentation
    this.app.get("/swagger.json", (req, res) => {
      res.json(swaggerDocument);
    });
    
    this.app.use("/api-docs", swaggerUi.serve, swaggerUi.setup(swaggerDocument, {
      explorer: true,
      customCss: '.swagger-ui .topbar { display: none }',
      swaggerOptions: {
        persistAuthorization: true,
        filter: true,
        displayRequestDuration: true,
        docExpansion: 'none' // Start with all sections collapsed
      }
    }));
  }

  private initializeRoutes(): void {
    // Auth routes
    this.app.use(`${APP_CONFIG.apiPrefix}/auth`, authRoutes);
    
    // API routes
    this.app.use(`${APP_CONFIG.apiPrefix}/urls`, urlRoutes);
    this.app.use(`${APP_CONFIG.apiPrefix}/analytics`, analyticsRoutes);

    // Redirection route (needs to be last to avoid conflicts)
    this.app.use("/", redirectRoutes);
  }

  private initializeErrorHandling(): void {
    this.app.use(errorHandler);
  }

  public async start(): Promise<void> {
    try {
      // Connect to MongoDB
      await connectDB();

      // Start the server
      const port = APP_CONFIG.port;
      this.app.listen(port, () => {
        logger.info(`Server running on port ${port}`);
        logger.info(
          `API Documentation available at ${APP_CONFIG.baseUrl}/api-docs`
        );
      });
    } catch (error) {
      logger.error("Failed to start the server", error);
      process.exit(1);
    }
  }
}

export default App;
src/config/logger.ts

// src/config/logger.ts

import { createLogger, format, transports } from "winston";
import { datadogLogs } from "@datadog/browser-logs";

// Initialize Datadog logs when in production
if (process.env.NODE_ENV === "production") {
  datadogLogs.init({
    clientToken: process.env.DATADOG_CLIENT_TOKEN || "",
    site: "us5.datadoghq.com",
    forwardErrorsToLogs: true,
    sessionSampleRate: 100,
  });
}

export const logger = createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: format.combine(
    format.timestamp({ format: "YYYY-MM-DD HH:mm:ss" }),
    format.errors({ stack: true }),
    format.splat(),
    format.json()
  ),
  defaultMeta: { service: "link-tracker" },
  transports: [
    new transports.Console({
      format: format.combine(
        format.colorize(),
        format.printf(({ timestamp, level, message, ...meta }) => {
          return `${timestamp} ${level}: ${message} ${
            Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ""
          }`;
        })
      ),
    }),
    new transports.File({ filename: "logs/error.log", level: "error" }),
    new transports.File({ filename: "logs/combined.log" }),
  ],
});

// Custom transport for Datadog in production
if (process.env.NODE_ENV === "production") {
  logger.add(
    new transports.Console({
      format: format.combine(format.json()),
      log: (info, callback) => {
        datadogLogs.logger.log(info.message, { level: info.level, ...info });
        callback();
      },
    })
  );
}
src/config/redis.ts

// src/config/redis.ts

import { createClient } from "redis";
import { logger } from "./logger";

export const REDIS_CONFIG = {
  host: process.env.REDIS_HOST || "localhost", // Use localhost as fallback
  port: Number(process.env.REDIS_PORT) || 6379,
  ttl: Number(process.env.REDIS_TTL) || 3600, // 1 hour in seconds
  prefix: process.env.REDIS_PREFIX || "link-tracker:", // Set a prefix for all keys
  enabled: process.env.REDIS_ENABLED !== "false", // Enable Redis by default
};

let redisClient: any = null;
let redisConnectionFailed = false;

export const getRedisClient = async () => {
  // If Redis is disabled or previous connection attempts failed, return a mock client
  if (!REDIS_CONFIG.enabled || redisConnectionFailed) {
    return createMockRedisClient();
  }

  if (!redisClient) {
    try {
      redisClient = createClient({
        url: `redis://${REDIS_CONFIG.host}:${REDIS_CONFIG.port}`,
      });

      redisClient.on("error", (err: any) => {
        logger.error("Redis Client Error", err);
        redisConnectionFailed = true;
        redisClient = null;
      });

      await redisClient.connect();
      logger.info("Redis client connected");
    } catch (error) {
      logger.error("Failed to connect to Redis", error);
      redisConnectionFailed = true;
      return createMockRedisClient();
    }
  }

  return redisClient;
};

// Create a mock client that doesn't do anything but doesn't crash
function createMockRedisClient() {
  return {
    get: async () => null,
    set: async () => true,
    del: async () => true,
    exists: async () => 0,
    incr: async () => 1,
    disconnect: async () => {},
  };
}

// Cleanup function
export const closeRedisConnection = async () => {
  if (redisClient) {
    await redisClient.disconnect();
    redisClient = null;
  }
};
src/config/app.ts

// src/config/app.ts

import dotenv from "dotenv";
dotenv.config();

export const APP_CONFIG = {
  port: process.env.PORT || 5000,
  environment: process.env.NODE_ENV || "development",
  baseUrl: process.env.BASE_URL || "http://localhost:5000",
  apiPrefix: "/api/v1",
  jwtSecret: process.env.JWT_SECRET || "your-default-jwt-secret-key-change-in-production",
  jwtExpiresIn: process.env.JWT_EXPIRES_IN || "24h",
};
src/config/cors.ts

// src/config/cors.ts

import cors from "cors";
import { CorsOptions } from "cors";
import { logger } from "./logger";

// Parse allowed origins from environment variable or default to localhost
const allowedOrigins = process.env.CORS_ALLOWED_ORIGINS
  ? process.env.CORS_ALLOWED_ORIGINS.split(",")
  : ["http://localhost:3000", "http://localhost:3001"];

logger.info(`CORS configured with allowed origins: ${allowedOrigins.join(", ")}`);

export const corsOptions: CorsOptions = {
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps, curl, Postman)
    if (!origin) {
      return callback(null, true);
    }
    
    // Check if origin is allowed
    if (allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      logger.warn(`CORS blocked request from origin: ${origin}`);
      callback(new Error("Not allowed by CORS"));
    }
  },
  methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
  allowedHeaders: [
    "Content-Type",
    "Authorization",
    "X-Requested-With",
    "X-CSRF-Token",
  ],
  credentials: true, // Allow cookies to be sent with requests
  maxAge: 86400, // Cache preflight requests for 24 hours
  preflightContinue: false,
  optionsSuccessStatus: 204,
};

// Middleware to add security headers
export const securityHeaders = (req: any, res: any, next: any) => {
  // Set security headers
  res.setHeader("X-Content-Type-Options", "nosniff");
  res.setHeader("X-Frame-Options", "DENY");
  res.setHeader("X-XSS-Protection", "1; mode=block");
  res.setHeader("Strict-Transport-Security", "max-age=31536000; includeSubDomains");
  res.setHeader("Referrer-Policy", "same-origin");
  
  // Content Security Policy
  if (process.env.NODE_ENV === "production") {
    res.setHeader(
      "Content-Security-Policy",
      "default-src 'self'; script-src 'self'; object-src 'none'; img-src 'self' data:; media-src 'self'; frame-src 'none'; font-src 'self'; connect-src 'self'"
    );
  }
  
  next();
};

// CORS middleware
export const corsMiddleware = cors(corsOptions); src/config/auth.ts

// src/config/auth.ts

/**
 * Authentication configuration
 */
export const AUTH_CONFIG = {
  JWT_SECRET: process.env.JWT_SECRET || "your-secret-key",
  JWT_REFRESH_SECRET: process.env.JWT_REFRESH_SECRET || "your-refresh-secret-key",
  JWT_EXPIRATION: 15 * 60, // 15 minutes in seconds
  JWT_REFRESH_EXPIRATION: 7 * 24 * 60 * 60, // 7 days in seconds
}; src/config/database.ts

// src/config/database.ts

import mongoose from "mongoose";
import { logger } from "./logger";

export const DB_CONFIG = {
  uri:
    process.env.MONGODB_URI ||
    `mongodb://${process.env.MONGO_INITDB_ROOT_USERNAME}:${process.env.MONGO_INITDB_ROOT_PASSWORD}@localhost:27017/link-tracker`,
  options: {
    serverSelectionTimeoutMS: 5000, // New default option to handle connection timeouts
    authSource: "admin",
  },
};

export const connectDB = async (): Promise<void> => {
  try {
    logger.info('Attempting to connect to MongoDB');
    await mongoose.connect(DB_CONFIG.uri, DB_CONFIG.options);
    logger.info("✅ MongoDB connected successfully");
  } catch (error) {
    logger.error("❌ MongoDB connection error", error);
    process.exit(1);
  }
};
src/routes/analyticsRoutes.ts

// src/routes/analyticsRoutes.ts

import { Router } from "express";
import { container } from "../di/container";
import { AnalyticsController } from "../controllers/analyticsController";
import { requestLogger } from "../middlewares/requestLogger";
import { TYPES } from "../di/types";

const router = Router();
const analyticsController = container.get<AnalyticsController>(TYPES.AnalyticsController);

/**
 * @swagger
 * /analytics/url/{urlId}:
 *   get:
 *     summary: Get clicks for a specific URL
 *     tags: [Analytics]
 *     parameters:
 *       - in: path
 *         name: urlId
 *         required: true
 *         schema:
 *           type: string
 *         description: The short ID of the URL
 *     responses:
 *       200:
 *         description: Analytics data retrieved successfully
 *       400:
 *         description: Invalid request
 *       500:
 *         description: Server error
 */
router.get("/url/:urlId", requestLogger, analyticsController.getClicksByUrlId);

/**
 * @swagger
 * /analytics/date-range:
 *   get:
 *     summary: Get clicks within a date range
 *     tags: [Analytics]
 *     parameters:
 *       - in: query
 *         name: startDate
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *         description: Start date in ISO format
 *       - in: query
 *         name: endDate
 *         required: true
 *         schema:
 *           type: string
 *           format: date
 *         description: End date in ISO format
 *     responses:
 *       200:
 *         description: Analytics data retrieved successfully
 *       400:
 *         description: Invalid request
 *       500:
 *         description: Server error
 */
router.get(
  "/date-range",
  requestLogger,
  analyticsController.getClicksByDateRange
);

/**
 * @swagger
 * /analytics/top:
 *   get:
 *     summary: Get top clicked URLs
 *     tags: [Analytics]
 *     parameters:
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of results to return
 *     responses:
 *       200:
 *         description: Top URLs retrieved successfully
 *       500:
 *         description: Server error
 */
router.get("/top", requestLogger, analyticsController.getTopClicks);

export default router;
src/routes/redirectRoutes.ts

// src/routes/redirectRoutes.ts

import { Router, Request, Response, NextFunction } from "express";
import { container } from "../di/container";
import { RedirectController } from "../controllers/redirectController";
import { requestLogger } from "../middlewares/requestLogger";
import { TYPES } from "../di/types";

const router = Router();
const redirectController = container.get<RedirectController>(TYPES.RedirectController);

/**
 * @swagger
 * /{shortId}:
 *   get:
 *     summary: Redirect to the original URL
 *     tags: [Redirect]
 *     parameters:
 *       - in: path
 *         name: shortId
 *         required: true
 *         schema:
 *           type: string
 *         description: The short ID of the URL
 *     responses:
 *       302:
 *         description: Redirects to the original URL
 *       404:
 *         description: URL not found
 *       500:
 *         description: Server error
 */
router.get("/:shortId", requestLogger, (req: Request, res: Response, next: NextFunction) => {
  redirectController.redirect(req, res, next);
});

export default router;
src/routes/authRoutes.ts

// src/routes/authRoutes.ts

import {
  Router,
  Request,
  Response,
  NextFunction,
  RequestHandler,
} from "express";
import { container } from "../di/container";
import { TYPES } from "../di/types";
import { AuthController } from "../controllers/authController";
import { validateRequest } from "../middlewares/validateRequest";
import { authenticateToken, AuthRequest } from "../middlewares/authMiddleware";
const { body } = require("express-validator");

const router = Router();
const authController = container.get<AuthController>(TYPES.AuthController);

// Define validation rules
const registerValidation = [
  body("email")
    .isEmail()
    .withMessage("Please provide a valid email")
    .normalizeEmail(),
  body("password")
    .isLength({ min: 6 })
    .withMessage("Password must be at least 6 characters long"),
  body("name").optional().trim().notEmpty().withMessage("Name cannot be empty"),
  validateRequest,
];

const loginValidation = [
  body("email")
    .isEmail()
    .withMessage("Please provide a valid email")
    .normalizeEmail(),
  body("password").notEmpty().withMessage("Password is required"),
  validateRequest,
];

// Route handlers with proper typing
const register: RequestHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    await authController.register(req, res);
  } catch (error) {
    next(error);
  }
};

const login: RequestHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    await authController.login(req, res);
  } catch (error) {
    next(error);
  }
};

const refreshToken: RequestHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authReq = req as AuthRequest;
    await authController.refreshToken(authReq, res);
  } catch (error) {
    next(error);
  }
};

const logout: RequestHandler = async (
  req: Request,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    const authReq = req as AuthRequest;
    await authController.logout(authReq, res);
  } catch (error) {
    next(error);
  }
};

// Routes with validation middleware
router.post("/register", registerValidation, register);
router.post("/login", loginValidation, login);
router.post("/refresh-token", authenticateToken, refreshToken);
router.post("/logout", authenticateToken, logout);

export default router;
src/routes/urlRoutes.ts

// src/routes/urlRoutes.ts

import { Router } from "express";
import { container } from "../di/container";
import { UrlController } from "../controllers/urlController";
import { requestLogger } from "../middlewares/requestLogger";
import { TYPES } from "../di/types";
import { authMiddleware } from "../middlewares/authMiddleware";

const router = Router();
const urlController = container.get<UrlController>(TYPES.UrlController);

/**
 * @swagger
 * /urls/shorten:
 *   post:
 *     summary: Shorten a URL
 *     tags: [URLs]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - url
 *             properties:
 *               url:
 *                 type: string
 *                 description: The original URL to shorten
 *               customSlug:
 *                 type: string
 *                 description: Optional custom slug for the shortened URL
 *     responses:
 *       201:
 *         description: URL shortened successfully
 *       400:
 *         description: Invalid request
 *       409:
 *         description: Custom slug already in use
 *       500:
 *         description: Server error
 */
router.post("/shorten", requestLogger, urlController.shortenUrl);

/**
 * @swagger
 * /urls/process-html:
 *   post:
 *     summary: Process HTML to replace links with trackable links
 *     tags: [URLs]
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - html
 *             properties:
 *               html:
 *                 type: string
 *                 description: HTML content with links to process
 *               baseUrl:
 *                 type: string
 *                 description: Optional base URL for the shortened links
 *     responses:
 *       200:
 *         description: HTML processed successfully
 *       400:
 *         description: Invalid request
 *       500:
 *         description: Server error
 */
router.post("/process-html", requestLogger, urlController.processHtml);

// Protected routes requiring auth
router.use(authMiddleware);

/**
 * @swagger
 * /api/v1/urls:
 *   get:
 *     summary: Get user's shortened URLs
 *     tags: [URLs]
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: page
 *         schema:
 *           type: integer
 *           default: 1
 *         description: Page number for pagination
 *       - in: query
 *         name: limit
 *         schema:
 *           type: integer
 *           default: 10
 *         description: Number of items per page
 *     responses:
 *       200:
 *         description: List of user's URLs
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                 urls:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Url'
 *                 total:
 *                   type: integer
 *                 page:
 *                   type: integer
 *                 totalPages:
 *                   type: integer
 */
router.get("/", requestLogger, urlController.getUserUrls);

export default router;
src/middlewares/authMiddleware.ts

// src/middlewares/authMiddleware.ts

import { Request, Response, NextFunction } from "express";
import { inject, injectable } from "inversify";
import { TYPES } from "../di/types";
import { AuthService } from "../services/authService";
import { AuthError } from "../errors/AuthError";
import { IAuthMiddleware } from "../interfaces/middlewares/IAuthMiddleware";
import { container } from "../di/container";
import jwt from "jsonwebtoken";
import { logger } from "../config/logger";
import { AUTH_CONFIG } from "../config/auth";
import UserModel, { UserDocument } from "../models/User";
import {
  createAccessToken,
  createRefreshToken,
  verifyAccessToken,
  verifyRefreshToken,
} from "../utils/tokenUtils";
import mongoose from "mongoose";

export interface AuthenticatedRequest extends Request {
  user?: {
    id: string;
    email: string;
    role: string;
  };
}

// Add this to fix the import in authRoutes.ts
export type AuthRequest = AuthenticatedRequest;

@injectable()
export class AuthMiddleware implements IAuthMiddleware {
  constructor(@inject(TYPES.AuthService) private authService: AuthService) {}

  authenticate = async (
    req: AuthenticatedRequest,
    res: Response,
    next: NextFunction
  ): Promise<void> => {
    try {
      // Check for token in Authorization header
      const authHeader = req.headers.authorization;

      // Get token from Authorization header or from cookies
      let token: string | undefined;

      if (authHeader && authHeader.startsWith("Bearer ")) {
        // Get token from header
        token = authHeader.split(" ")[1];
      } else if (req.cookies.accessToken) {
        // Get token from cookie
        token = req.cookies.accessToken;
      }

      if (!token) {
        res.status(401).json({
          success: false,
          message: "Authentication required",
        });
        return;
      }

      try {
        // Verify token
        const decoded = verifyAccessToken(token);

        // Set user in request object
        req.user = {
          id: decoded.id,
          email: decoded.email,
          role: decoded.role || "user",
        };

        next();
      } catch (error) {
        // If token verification fails, try to refresh token
        if (req.cookies.refreshToken) {
          try {
            // Verify refresh token
            const decoded = verifyRefreshToken(req.cookies.refreshToken);

            // Find user
            const user = await UserModel.findById(decoded.id);

            if (!user) {
              throw new Error("User not found");
            }

            // Create new tokens
            const accessToken = createAccessToken(user);
            const refreshToken = createRefreshToken(user);

            // Set new cookies
            setTokenCookies(res, accessToken, refreshToken);

            // Set user in request object
            req.user = {
              id:
                user._id instanceof mongoose.Types.ObjectId
                  ? user._id.toString()
                  : String(user._id),
              email: user.email,
              role: user.role || "user",
            };

            next();
          } catch (refreshError) {
            // If refresh token is invalid, clear cookies and return 401
            clearTokenCookies(res);
            res.status(401).json({
              success: false,
              message: "Session expired. Please login again.",
            });
          }
        } else {
          // No refresh token, clear cookies and return 401
          clearTokenCookies(res);
          res.status(401).json({
            success: false,
            message: "Authentication failed",
          });
        }
      }
    } catch (error) {
      logger.error("Auth middleware error:", {
        error: error instanceof Error ? error.message : String(error),
      });
      res.status(500).json({
        success: false,
        message: "Internal server error",
      });
    }
  };

  requireRole = (roles: string[]) => {
    return (
      req: AuthenticatedRequest,
      res: Response,
      next: NextFunction
    ): void => {
      if (!req.user) {
        res.status(401).json({
          success: false,
          message: "Authentication required",
        });
        return;
      }

      if (roles.includes(req.user.role)) {
        next();
      } else {
        res.status(403).json({
          success: false,
          message: "You don't have permission to access this resource",
        });
      }
    };
  };
}

// Export a function that gets the middleware from the container
export const authMiddleware = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const middleware = container.get<AuthMiddleware>(TYPES.AuthMiddleware);
  middleware.authenticate(req as AuthenticatedRequest, res, next);
};

// Export authenticateToken for direct usage in routes
export const authenticateToken = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const middleware = container.get<AuthMiddleware>(TYPES.AuthMiddleware);
  middleware.authenticate(req as AuthenticatedRequest, res, next);
};

/**
 * Optional authentication middleware that doesn't require authentication
 * but still sets the user object if a valid token is provided
 */
export const optionalAuthenticate = async (
  req: AuthenticatedRequest,
  res: Response,
  next: NextFunction
): Promise<void> => {
  try {
    // Check for token in Authorization header
    const authHeader = req.headers.authorization;

    // Get token from Authorization header or from cookies
    let token: string | undefined;

    if (authHeader && authHeader.startsWith("Bearer ")) {
      // Get token from header
      token = authHeader.split(" ")[1];
    } else if (req.cookies.accessToken) {
      // Get token from cookie
      token = req.cookies.accessToken;
    }

    if (!token) {
      // No token, continue without authentication
      next();
      return;
    }

    try {
      // Verify token
      const decoded = verifyAccessToken(token);

      // Set user in request object
      req.user = {
        id: decoded.id,
        email: decoded.email,
        role: decoded.role || "user",
      };

      next();
    } catch (error) {
      // If token verification fails, try refresh token
      if (req.cookies.refreshToken) {
        try {
          // Verify refresh token
          const decoded = verifyRefreshToken(req.cookies.refreshToken);

          // Find user
          const user = await UserModel.findById(decoded.id);

          if (user) {
            // Create new tokens
            const accessToken = createAccessToken(user);
            const refreshToken = createRefreshToken(user);

            // Set new cookies
            setTokenCookies(res, accessToken, refreshToken);

            // Set user in request object
            req.user = {
              id:
                user._id instanceof mongoose.Types.ObjectId
                  ? user._id.toString()
                  : String(user._id),
              email: user.email,
              role: user.role || "user",
            };
          }

          next();
        } catch (refreshError) {
          // Ignore refresh token errors in optional auth
          clearTokenCookies(res);
          next();
        }
      } else {
        next();
      }
    }
  } catch (error) {
    logger.error("Optional auth middleware error:", {
      error: error instanceof Error ? error.message : String(error),
    });
    // Continue without authentication
    next();
  }
};

/**
 * CSRF protection middleware
 */
export const csrfProtection = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  // Only apply to non-GET methods
  if (req.method !== "GET") {
    const csrfToken = req.headers["x-csrf-token"];
    const cookieToken = req.cookies.csrfToken;

    if (!csrfToken || !cookieToken || csrfToken !== cookieToken) {
      res.status(403).json({
        success: false,
        message: "CSRF validation failed",
      });
      return;
    }
  }

  next();
};

// Helper functions for token cookies

export const setTokenCookies = (
  res: Response,
  accessToken: string,
  refreshToken: string
): void => {
  // Set access token as HTTP-only cookie
  res.cookie("accessToken", accessToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    maxAge: AUTH_CONFIG.JWT_EXPIRATION * 1000, // Convert seconds to milliseconds
  });

  // Set refresh token as HTTP-only cookie
  res.cookie("refreshToken", refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "strict",
    path: "/api/v1/auth/refresh", // Only sent to refresh endpoint
    maxAge: AUTH_CONFIG.JWT_REFRESH_EXPIRATION * 1000, // Convert seconds to milliseconds
  });
};

export const clearTokenCookies = (res: Response): void => {
  res.clearCookie("accessToken");
  res.clearCookie("refreshToken", { path: "/api/v1/auth/refresh" });
};
src/middlewares/instances.ts

// src/middlewares/instances.ts

import { container } from '../di/container';
import { TYPES } from '../di/types';
import { AuthMiddleware } from './authMiddleware';

// Get middleware instances from container
const authMiddleware = container.get<AuthMiddleware>(TYPES.AuthMiddleware);

// Export bound middleware functions
export const authenticateToken = authMiddleware.authenticate.bind(authMiddleware); src/middlewares/errorHandler.ts

// src/middlewares/errorHandler.ts

import { Request, Response, NextFunction } from "express";
import { logger } from "../config/logger";
import { AuthError } from "../errors/AuthError";

interface ExtendedError extends Error {
  status?: number;
  code?: string;
}

export const errorHandler = (
  err: ExtendedError,
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  console.error('Error details:', err);
  
  if (err instanceof AuthError) {
    res.status(err.statusCode).json({
      success: false,
      message: err.message,
      code: err.code
    });
    return;
  }

  const status = err.status || 500;
  const message = err.message || "Something went wrong";

  logger.error(`${status} - ${message}`, {
    error: err.stack,
    method: req.method,
    path: req.path,
    ip: req.ip,
  });

  res.status(status).json({
    success: false,
    message,
    code: err.code || 'INTERNAL_SERVER_ERROR'
  });
};
src/middlewares/validateRequest.ts

// src/middlewares/validateRequest.ts

import { Request, Response, NextFunction } from 'express';
const { validationResult } = require('express-validator');

interface ValidationError {
  param: string;
  msg: string;
}

export const validateRequest = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      errors: errors.array().map((err: ValidationError) => ({
        field: err.param,
        message: err.msg
      }))
    });
  }
  next();
}; src/middlewares/rateLimiter.ts

// src/middlewares/rateLimiter.ts

import { Request, Response, NextFunction } from "express";
import rateLimit from "express-rate-limit";
import RedisStore from "rate-limit-redis";
import Redis from "ioredis";
import { logger } from "../config/logger";

// Redis client for rate limiting
let redisClient: Redis | null = null;

try {
  if (process.env.REDIS_URL) {
    redisClient = new Redis(process.env.REDIS_URL);
    logger.info("Redis client initialized for rate limiting");
  }
} catch (error) {
  logger.error("Failed to initialize Redis client:", { error: error instanceof Error ? error.message : String(error) });
}

// Create store based on available options
const createStore = () => {
  if (redisClient) {
    return new RedisStore({
      // @ts-ignore - Type mismatch in package, but it works
      sendCommand: (...args: unknown[]) => redisClient!.call(...args),
      prefix: "ratelimit:",
    });
  }
  
  logger.warn("Using memory store for rate limiting - not recommended for production");
  return undefined; // Will use default memory store
};

// General API rate limiter - applies to all routes
export const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  legacyHeaders: false, // Disable the `X-RateLimit-*` headers
  store: createStore(),
  message: {
    success: false,
    message: "Too many requests, please try again later.",
  },
  handler: (req: Request, res: Response, _next: NextFunction) => {
    logger.warn("Rate limit exceeded", {
      ip: req.ip,
      path: req.path,
      method: req.method,
    });
    res.status(429).json({
      success: false,
      message: "Too many requests, please try again later.",
    });
  },
  skip: (req: Request) => {
    // Skip rate limiting for certain endpoints if needed
    return false;
  },
});

// Stricter rate limiter for auth routes to prevent brute force attacks
export const authLimiter = rateLimit({
  windowMs: 60 * 60 * 1000, // 1 hour
  max: 10, // Limit each IP to 10 requests per windowMs
  standardHeaders: true,
  legacyHeaders: false,
  store: createStore(),
  message: {
    success: false,
    message: "Too many login attempts, please try again later.",
  },
  handler: (req: Request, res: Response, _next: NextFunction) => {
    logger.warn("Auth rate limit exceeded", {
      ip: req.ip,
      path: req.path,
      method: req.method,
    });
    res.status(429).json({
      success: false,
      message: "Too many login attempts, please try again later.",
    });
  },
});

// URL shortening limiter
export const urlShorteningLimiter = rateLimit({
  windowMs: 5 * 60 * 1000, // 5 minutes
  max: 20, // Limit each IP to 20 requests per windowMs
  standardHeaders: true,
  legacyHeaders: false,
  store: createStore(),
  message: {
    success: false,
    message: "Too many URL shortening requests, please try again later.",
  },
  handler: (req: Request, res: Response, _next: NextFunction) => {
    logger.warn("URL shortening rate limit exceeded", {
      ip: req.ip,
      path: req.path,
      method: req.method,
    });
    res.status(429).json({
      success: false,
      message: "Too many URL shortening requests, please try again later.",
    });
  },
}); src/middlewares/requestLogger.ts

// src/middlewares/requestLogger.ts

import { Request, Response, NextFunction } from "express";
import { logger } from "../config/logger";

export const requestLogger = (
  req: Request,
  res: Response,
  next: NextFunction
): void => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = Date.now() - start;
    const logLevel = res.statusCode >= 400 ? "warn" : "info";

    logger[logLevel](`${req.method} ${req.originalUrl}`, {
      method: req.method,
      url: req.originalUrl,
      status: res.statusCode,
      duration: `${duration}ms`,
      ip: req.ip,
      userAgent: req.headers["user-agent"],
    });
  });

  next();
};
src/types/express/index.d.ts

// src/types/express/index.d.ts

import { User } from '../../models/User';

declare global {
  namespace Express {
    interface Request {
      user?: {
        id: string;
        email: string;
        role: string;
      };
      csrfToken?: string;
    }
  }
} src/di/container.ts

// src/di/container.ts

import { Container } from "inversify";
import "reflect-metadata";
import { TYPES } from "./types";

// Repositories
import { IUrlRepository } from "../interfaces/repositories/IUrlRepository";
import { UrlRepository } from "../repositories/UrlRepository";
import { IAnalyticsRepository } from "../interfaces/repositories/IAnalyticsRepository";
import { AnalyticsRepository } from "../repositories/AnalyticsRepository";
import { IUserRepository } from "../interfaces/repositories/IUserRepository";
import { UserRepository } from "../repositories/UserRepository";

// Services
import { ILoggingService } from "../interfaces/services/ILoggingService";
import { LoggingService } from "../services/LoggingService";
import { IUrlShortenerService } from "../interfaces/services/IUrlShortenerService";
import { UrlShortenerService } from "../services/UrlShortenerService";
import { IHtmlProcessorService } from "../interfaces/services/IHtmlProcessorService";
import { HtmlProcessorService } from "../services/HtmlProcessorService";
import { IRedirectionService } from "../interfaces/services/IRedirectionService";
import { RedirectionService } from "../services/RedirectionService";
import { IAuthService } from "../interfaces/services/IAuthService";
import { AuthService } from "../services/authService";
import { TokenService } from '../services/tokenService';
import { UserService } from '../services/userService';

// Controllers
import { UrlController } from "../controllers/urlController";
import { RedirectController } from "../controllers/redirectController";
import { AnalyticsController } from "../controllers/analyticsController";
import { AuthController } from "../controllers/authController";

import { IAuthMiddleware } from "../interfaces/middlewares/IAuthMiddleware";
import { AuthMiddleware } from '../middlewares/authMiddleware';

const container = new Container();

// Bind repositories
container
  .bind<IUrlRepository>(TYPES.UrlRepository)
  .to(UrlRepository)
  .inSingletonScope();
container
  .bind<IAnalyticsRepository>(TYPES.AnalyticsRepository)
  .to(AnalyticsRepository)
  .inSingletonScope();
container
  .bind<IUserRepository>(TYPES.UserRepository)
  .to(UserRepository)
  .inSingletonScope();

// Bind services
container
  .bind<ILoggingService>(TYPES.LoggingService)
  .to(LoggingService)
  .inSingletonScope();
container
  .bind<IUrlShortenerService>(TYPES.UrlShortenerService)
  .to(UrlShortenerService)
  .inSingletonScope();
container
  .bind<IHtmlProcessorService>(TYPES.HtmlProcessorService)
  .to(HtmlProcessorService)
  .inSingletonScope();
container
  .bind<IRedirectionService>(TYPES.RedirectionService)
  .to(RedirectionService)
  .inSingletonScope();
container
  .bind<IAuthService>(TYPES.AuthService)
  .to(AuthService)
  .inSingletonScope();
container
  .bind<TokenService>(TYPES.TokenService)
  .to(TokenService)
  .inSingletonScope();
container
  .bind<UserService>(TYPES.UserService)
  .to(UserService)
  .inSingletonScope();

// Bind controllers
container.bind<UrlController>(TYPES.UrlController).to(UrlController).inSingletonScope();
container.bind<RedirectController>(TYPES.RedirectController).to(RedirectController).inSingletonScope();
container.bind<AnalyticsController>(TYPES.AnalyticsController).to(AnalyticsController).inSingletonScope();
container.bind<AuthController>(TYPES.AuthController).to(AuthController).inSingletonScope();

// Bind middlewares
container.bind<IAuthMiddleware>(TYPES.AuthMiddleware).to(AuthMiddleware).inSingletonScope();

export { container };
src/di/types.ts

// src/di/types.ts

export const TYPES = {
  // Controllers
  AuthController: Symbol.for("AuthController"),
  UrlController: Symbol.for("UrlController"),
  AnalyticsController: Symbol.for("AnalyticsController"),
  RedirectController: Symbol.for("RedirectController"),

  // Services
  HtmlProcessorService: Symbol.for("HtmlProcessorService"),
  UrlShortenerService: Symbol.for("UrlShortenerService"),
  RedirectionService: Symbol.for("RedirectionService"),
  AuthService: Symbol.for("AuthService"),
  LoggingService: Symbol.for("LoggingService"),
  TokenService: Symbol.for("TokenService"),
  UserService: Symbol.for("UserService"),

  // Repositories
  UrlRepository: Symbol.for("UrlRepository"),
  AnalyticsRepository: Symbol.for("AnalyticsRepository"),
  UserRepository: Symbol.for("UserRepository"),

  // Middlewares
  AuthMiddleware: Symbol.for("AuthMiddleware"),
};
src/server.ts

// src/server.ts

import App from "./app";
import { logger } from "./config/logger";
import { closeRedisConnection } from "./config/redis";

const app = new App();

// Graceful shutdown
process.on("SIGTERM", async () => {
  logger.info("SIGTERM signal received. Shutting down gracefully");
  await closeRedisConnection();
  process.exit(0);
});

process.on("SIGINT", async () => {
  logger.info("SIGINT signal received. Shutting down gracefully");
  await closeRedisConnection();
  process.exit(0);
});

// Handle uncaught exceptions
process.on("uncaughtException", (error) => {
  logger.error("Uncaught exception", error);
  process.exit(1);
});

// Handle unhandled promise rejections
process.on("unhandledRejection", (reason, promise) => {
  logger.error("Unhandled promise rejection", { reason, promise });
  process.exit(1);
});

// Start the application
app.start().catch((error) => {
  logger.error("Failed to start application", error);
  process.exit(1);
});
src/interfaces/repositories/IUrlRepository.ts

// src/interfaces/repositories/IUrlRepository.ts

import { Url } from "../../models/Url";

export interface IUrlRepository {
  create(url: Partial<Url>): Promise<Url>;
  findByShortId(shortId: string): Promise<Url | null>;
  findByOriginalUrl(originalUrl: string): Promise<Url | null>;
  updateById(id: string, update: Partial<Url>): Promise<Url | null>;
  findByUserId(userId: string, options?: { skip?: number; limit?: number }): Promise<Url[]>;
  countByUserId(userId: string): Promise<number>;
  delete(id: string): Promise<boolean>;
}
src/interfaces/repositories/IAnalyticsRepository.ts

// src/interfaces/repositories/IAnalyticsRepository.ts

import { ClickEvent } from "../../models/ClickEvent";

export interface IAnalyticsRepository {
  createClickEvent(clickEvent: Partial<ClickEvent>): Promise<ClickEvent>;
  getClicksByUrlId(urlId: string): Promise<ClickEvent[]>;
  getClicksByDateRange(startDate: Date, endDate: Date): Promise<ClickEvent[]>;
  getTopClicks(limit: number): Promise<{ url: string; clicks: number }[]>;
}
src/interfaces/repositories/IUserRepository.ts

// src/interfaces/repositories/IUserRepository.ts

import { User } from "../../models/User";

export interface IUserRepository {
  findByEmail(email: string): Promise<User | null>;
  findById(id: string): Promise<User | null>;
  create(user: Partial<User>): Promise<User>;
  updateById(id: string, updates: Partial<User>): Promise<User | null>;
}
src/interfaces/services/IHtmlProcessorService.ts

// src/interfaces/services/IHtmlProcessorService.ts

export interface IHtmlProcessorService {
  processHtml(html: string, baseUrl?: string): Promise<string>;
  extractUrls(html: string): string[];
}
src/interfaces/services/IUrlService.ts

// src/interfaces/services/IUrlService.ts

import { Url } from '../../models/Url';

export interface IUrlService {
  createUrl(originalUrl: string, userId: string): Promise<Url>;
  getUrlByShortId(shortId: string): Promise<Url | null>;
  getUrlsByUserId(userId: string): Promise<Url[]>;
  deleteUrl(urlId: string, userId: string): Promise<boolean>;
  updateUrl(urlId: string, userId: string, updates: Partial<Url>): Promise<Url | null>;
  incrementClicks(shortId: string): Promise<void>;
  getUrlStats(shortId: string): Promise<{
    totalClicks: number;
    lastClicked?: Date;
    createdAt: Date;
  }>;
} src/interfaces/services/IRedirectionService.ts

// src/interfaces/services/IRedirectionService.ts

import { Request, Response, NextFunction } from "express";

export interface IRedirectionService {
  redirect(req: Request, res: Response, next: NextFunction): Promise<void>;
  recordClickEvent(shortId: string, req: Request): Promise<void>;
}
src/interfaces/services/IAuthService.ts

// src/interfaces/services/IAuthService.ts

import { User } from "../../models/User";
import { AuthTokens } from "../auth/tokens";

export interface IAuthService {
  registerUser(email: string, password: string, name?: string): Promise<User>;
  loginUser(email: string, password: string): Promise<{ user: User; tokens: AuthTokens }>;
  refreshToken(refreshToken: string): Promise<AuthTokens>;
  logout(refreshToken: string): Promise<void>;
  refreshApiKey(userId: string): Promise<string>;
}
src/interfaces/services/IUrlShortenerService.ts

// src/interfaces/services/IUrlShortenerService.ts

import { Url } from "../../models/Url";

export interface IUrlShortenerService {
  shortenUrl(originalUrl: string, customSlug?: string): Promise<Url>;
  getOriginalUrl(shortId: string): Promise<string | null>;
}
src/interfaces/services/ILoggingService.ts

// src/interfaces/services/ILoggingService.ts

export interface LogContext {
  [key: string]: any;
}

export interface ILoggingService {
  info(message: string, context?: LogContext): void;
  error(message: string, error?: Error, context?: LogContext): void;
  warn(message: string, context?: LogContext): void;
  debug(message: string, context?: LogContext): void;
}
src/interfaces/auth/tokens.ts

// src/interfaces/auth/tokens.ts

export interface TokenPayload {
  userId: string;
  email: string;
  role: string;
}

export interface RefreshTokenPayload {
  userId: string;
  version: string; // For token invalidation
}

export interface AuthTokens {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
} src/interfaces/middlewares/IAuthMiddleware.ts

// src/interfaces/middlewares/IAuthMiddleware.ts

import { Request, Response, NextFunction } from 'express';

export interface IAuthMiddleware {
  authenticate(req: Request, res: Response, next: NextFunction): Promise<void>;
  requireRole(roles: string[]): (req: Request, res: Response, next: NextFunction) => void;
} src/interfaces/controllers/IAnalyticsController.ts

// src/interfaces/controllers/IAnalyticsController.ts

import { Request, Response } from "express";

export interface IAnalyticsController {
  getUrlAnalytics(req: Request, res: Response): Promise<void>;
} src/interfaces/controllers/IAuthController.ts

// src/interfaces/controllers/IAuthController.ts

import { Request, Response } from "express";

export interface IAuthController {
  register(req: Request, res: Response): Promise<void>;
  login(req: Request, res: Response): Promise<void>;
} src/interfaces/controllers/IRedirectController.ts

// src/interfaces/controllers/IRedirectController.ts

import { Request, Response, NextFunction } from "express";

export interface IRedirectController {
  redirect(req: Request, res: Response, next: NextFunction): Promise<void>;
} src/interfaces/controllers/IUrlController.ts

// src/interfaces/controllers/IUrlController.ts

import { Request, Response } from "express";

export interface IUrlController {
  createShortUrl(req: Request, res: Response): Promise<void>;
  getUserUrls(req: Request, res: Response): Promise<void>;
  processHtml(req: Request, res: Response): Promise<void>;
} src/controllers/authController.ts

// src/controllers/authController.ts

// controllers/authController.ts
import { Request, Response } from "express";
import { injectable, inject } from "inversify";
import { AuthService } from "../services/authService";
import { ILoggingService } from "../interfaces/services/ILoggingService";
import { TYPES } from "../di/types";

@injectable()
export class AuthController {
  constructor(
    @inject(TYPES.AuthService) private authService: AuthService,
    @inject(TYPES.LoggingService) private logger: ILoggingService
  ) {}

  async register(req: Request, res: Response): Promise<void> {
    try {
      const { email, password, name } = req.body;
      console.log('Registration attempt:', { email, name }); // Don't log password

      if (!email || !password) {
        console.log('Missing required fields');
        res
          .status(400)
          .json({
            success: false,
            message: "Email and password are required.",
          });
        return;
      }

      const user = await this.authService.registerUser(email, password, name);
      console.log('User registered successfully:', { userId: user._id });
      res.status(201).json({
        success: true,
        message: "User registered successfully.",
        userId: user._id,
      });
    } catch (error) {
      console.error('Registration error:', error);
      this.logger.error("Registration failed", error as Error);

      if ((error as Error).message === "User already exists") {
        res
          .status(409)
          .json({ success: false, message: "User already exists." });
      } else {
        res
          .status(500)
          .json({ success: false, message: "Registration failed." });
      }
    }
  }

  async login(req: Request, res: Response): Promise<void> {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        res
          .status(400)
          .json({
            success: false,
            message: "Email and password are required.",
          });
        return;
      }

      const { user, tokens } = await this.authService.loginUser(
        email,
        password
      );

      res.status(200).json({
        success: true,
        message: "Login successful.",
        token: tokens.accessToken,
        refreshToken: tokens.refreshToken,
        user,
      });
    } catch (error) {
      this.logger.error("Login failed", error as Error);

      if ((error as Error).message === "Invalid credentials") {
        res
          .status(401)
          .json({ success: false, message: "Invalid credentials." });
      } else {
        res.status(500).json({ success: false, message: "Login failed." });
      }
    }
  }

  async refreshToken(req: Request, res: Response): Promise<void> {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        res
          .status(400)
          .json({ success: false, message: "Refresh token is required." });
        return;
      }

      const newToken = await this.authService.refreshToken(refreshToken);

      res.status(200).json({
        success: true,
        token: newToken,
      });
    } catch (error) {
      this.logger.error("Token refresh failed", error as Error);
      res
        .status(401)
        .json({ success: false, message: "Invalid refresh token." });
    }
  }

  async logout(req: Request, res: Response): Promise<void> {
    try {
      const { refreshToken } = req.body;

      if (!refreshToken) {
        res
          .status(400)
          .json({ success: false, message: "Refresh token is required." });
        return;
      }

      await this.authService.logout(refreshToken);

      res.status(200).json({
        success: true,
        message: "Logged out successfully.",
      });
    } catch (error) {
      this.logger.error("Logout failed", error as Error);
      res.status(500).json({ success: false, message: "Logout failed." });
    }
  }
}
src/controllers/redirectController.ts

// src/controllers/redirectController.ts

import { Request, Response, NextFunction } from "express";
import { injectable, inject } from "inversify";
import { IRedirectionService } from "../interfaces/services/IRedirectionService";
import { ILoggingService } from "../interfaces/services/ILoggingService";
import { TYPES } from "../di/types";

@injectable()
export class RedirectController {
  constructor(
    @inject(TYPES.RedirectionService)
    private redirectionService: IRedirectionService,
    @inject(TYPES.LoggingService) private logger: ILoggingService
  ) {}

  redirect = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      await this.redirectionService.redirect(req, res, next);
    } catch (error: any) {
      this.logger.error("Redirection controller error", error);
      res.status(500).json({
        error: error.message || "An error occurred during redirection",
      });
    }
  };
}
src/controllers/urlController.ts

// src/controllers/urlController.ts

import { Request, Response, NextFunction } from "express";
import { injectable, inject } from "inversify";
import { IUrlShortenerService } from "../interfaces/services/IUrlShortenerService";
import { IHtmlProcessorService } from "../interfaces/services/IHtmlProcessorService";
import { ILoggingService } from "../interfaces/services/ILoggingService";
import { TYPES } from "../di/types";
import { IUrlRepository } from "../interfaces/repositories/IUrlRepository";

@injectable()
export class UrlController {
  constructor(
    @inject(TYPES.UrlShortenerService)
    private urlShortenerService: IUrlShortenerService,
    @inject(TYPES.HtmlProcessorService)
    private htmlProcessorService: IHtmlProcessorService,
    @inject(TYPES.LoggingService) private logger: ILoggingService,
    @inject(TYPES.UrlRepository) private urlRepository: IUrlRepository
  ) {}

  shortenUrl = async (req: Request, res: Response): Promise<void> => {
    try {
      const { url, customSlug } = req.body;

      if (!url) {
        res.status(400).json({ error: "URL is required" });
        return;
      }

      const shortenedUrl = await this.urlShortenerService.shortenUrl(
        url,
        customSlug
      );

      res.status(201).json({
        originalUrl: shortenedUrl.originalUrl,
        shortUrl: `${req.protocol}://${req.get("host")}/${
          shortenedUrl.shortId
        }`,
        shortId: shortenedUrl.shortId,
        customSlug: shortenedUrl.customSlug,
        createdAt: shortenedUrl.createdAt,
      });
    } catch (error: any) {
      this.logger.error("Error shortening URL", error);
      res
        .status(error.message === "Custom slug already in use" ? 409 : 500)
        .json({
          error: error.message || "An error occurred while shortening the URL",
        });
    }
  };

  processHtml = async (req: Request, res: Response): Promise<void> => {
    try {
      const { html, baseUrl } = req.body;

      if (!html) {
        res.status(400).json({ error: "HTML content is required" });
        return;
      }

      const processedHtml = await this.htmlProcessorService.processHtml(
        html,
        baseUrl || `${req.protocol}://${req.get("host")}`
      );

      res.status(200).json({
        processedHtml,
        originalLinks: this.htmlProcessorService.extractUrls(html).length,
        processedLinks:
          this.htmlProcessorService.extractUrls(processedHtml).length,
      });
    } catch (error: any) {
      this.logger.error("Error processing HTML", error);
      res.status(500).json({
        error: error.message || "An error occurred while processing the HTML",
      });
    }
  };

  async getUserUrls(req: Request, res: Response, next: NextFunction): Promise<void> {
    try {
      const userId = (req as any).user?.userId;
      
      if (!userId) {
        res.status(401).json({
          success: false,
          message: "User not authenticated",
        });
        return;
      }

      // Default pagination parameters
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 10;
      const skip = (page - 1) * limit;

      // Get URLs created by this user
      const urls = await this.urlRepository.findByUserId(userId, { skip, limit });
      const total = await this.urlRepository.countByUserId(userId);

      res.status(200).json({
        success: true,
        urls,
        total,
        page,
        totalPages: Math.ceil(total / limit),
      });
    } catch (error) {
      this.logger.error("Error fetching user URLs", error as Error);
      next(error);
    }
  }
}
src/controllers/htmlProcessorController.ts

// src/controllers/htmlProcessorController.ts

import { Request, Response } from "express";
import { injectable, inject } from "inversify";
import { TYPES } from "../di/types";
import { IUrlService } from "../interfaces/services/IUrlService";
import { logger } from "../config/logger";
import { AuthenticatedRequest } from "../middlewares/authMiddleware";
import { JSDOM } from "jsdom";

@injectable()
export class HtmlProcessorController {
  constructor(
    @inject(TYPES.UrlService) private urlService: IUrlService
  ) {}

  /**
   * Process HTML content by replacing all URLs with shortened, tracked links
   */
  processHtml = async (req: AuthenticatedRequest, res: Response): Promise<void> => {
    try {
      const { htmlContent, baseUrl } = req.body;

      if (!htmlContent || !baseUrl) {
        res.status(400).json({
          success: false,
          message: "HTML content and base URL are required",
        });
        return;
      }

      // Validate base URL
      try {
        new URL(baseUrl);
      } catch (error) {
        res.status(400).json({
          success: false,
          message: "Invalid base URL",
        });
        return;
      }

      // Parse HTML using JSDOM
      const dom = new JSDOM(htmlContent);
      const document = dom.window.document;

      // Find all links
      const links = document.querySelectorAll("a");
      const processedLinks: { original: string; shortened: string }[] = [];

      // Process each link
      for (let i = 0; i < links.length; i++) {
        const link = links[i];
        const href = link.getAttribute("href");

        if (href && !href.startsWith("#") && !href.startsWith("javascript:")) {
          try {
            // Normalize URL (handle relative URLs)
            const absoluteUrl = new URL(href, baseUrl).href;
            
            // Create shortened URL
            const shortUrl = await this.createShortenedUrl(absoluteUrl, req.user?.id);
            
            // Update link in DOM
            link.setAttribute("href", shortUrl);
            
            // Track processed link
            processedLinks.push({
              original: absoluteUrl,
              shortened: shortUrl,
            });
          } catch (error) {
            logger.warn(`Error processing link: ${href}`, { error });
            // Continue with next link if one fails
          }
        }
      }

      // Get processed HTML
      const processedHtml = dom.serialize();

      res.status(200).json({
        success: true,
        message: "HTML processed successfully",
        processedHtml,
        stats: {
          totalLinks: links.length,
          processedLinks: processedLinks.length,
          links: processedLinks,
        },
      });
    } catch (error) {
      logger.error("Error processing HTML:", { error: error instanceof Error ? error.message : String(error) });
      res.status(500).json({
        success: false,
        message: "Failed to process HTML content",
      });
    }
  };

  /**
   * Helper method to create shortened URL
   */
  private async createShortenedUrl(originalUrl: string, userId?: string): Promise<string> {
    try {
      // Check if URL already exists
      const existingUrl = await this.urlService.findByOriginalUrl(originalUrl);
      
      if (existingUrl) {
        return existingUrl.shortUrl;
      }
      
      // Create new shortened URL
      const result = await this.urlService.create({
        originalUrl,
        creator: userId, // Will be undefined for anonymous requests
      });
      
      return result.shortUrl;
    } catch (error) {
      logger.error("Error creating shortened URL:", { error: error instanceof Error ? error.message : String(error) });
      throw error;
    }
  }
} src/controllers/analyticsController.ts

// src/controllers/analyticsController.ts

import { Request, Response } from "express";
import { injectable, inject } from "inversify";
import { IAnalyticsRepository } from "../interfaces/repositories/IAnalyticsRepository";
import { ILoggingService } from "../interfaces/services/ILoggingService";
import { TYPES } from "../di/types";

@injectable()
export class AnalyticsController {
  constructor(
    @inject(TYPES.AnalyticsRepository)
    private analyticsRepository: IAnalyticsRepository,
    @inject(TYPES.LoggingService) private logger: ILoggingService
  ) {}

  getClicksByUrlId = async (req: Request, res: Response): Promise<void> => {
    try {
      const { urlId } = req.params;

      if (!urlId) {
        res.status(400).json({ error: "URL ID is required" });
        return;
      }

      const clicks = await this.analyticsRepository.getClicksByUrlId(urlId);

      res.status(200).json({
        urlId,
        totalClicks: clicks.length,
        clicks,
      });
    } catch (error: any) {
      this.logger.error("Error getting clicks by URL ID", error);
      res.status(500).json({
        error:
          error.message || "An error occurred while retrieving analytics data",
      });
    }
  };

  getClicksByDateRange = async (req: Request, res: Response): Promise<void> => {
    try {
      const { startDate, endDate } = req.query;

      if (!startDate || !endDate) {
        res.status(400).json({ error: "Start date and end date are required" });
        return;
      }

      const start = new Date(startDate as string);
      const end = new Date(endDate as string);

      if (isNaN(start.getTime()) || isNaN(end.getTime())) {
        res.status(400).json({ error: "Invalid date format" });
        return;
      }

      const clicks = await this.analyticsRepository.getClicksByDateRange(
        start,
        end
      );

      res.status(200).json({
        startDate: start,
        endDate: end,
        totalClicks: clicks.length,
        clicks,
      });
    } catch (error: any) {
      this.logger.error("Error getting clicks by date range", error);
      res.status(500).json({
        error:
          error.message || "An error occurred while retrieving analytics data",
      });
    }
  };

  getTopClicks = async (req: Request, res: Response): Promise<void> => {
    try {
      const limit = parseInt(req.query.limit as string) || 10;

      const topClicks = await this.analyticsRepository.getTopClicks(limit);

      res.status(200).json({
        limit,
        topClicks,
      });
    } catch (error: any) {
      this.logger.error("Error getting top clicks", error);
      res.status(500).json({
        error:
          error.message || "An error occurred while retrieving top clicks data",
      });
    }
  };
}
src/tests/integration/api/urls.test.ts

// src/tests/integration/api/urls.test.ts

import request from "supertest";
import { app } from "../../../app";
import { getTestToken } from "../../helpers/auth";

describe("URL Endpoints", () => {
  let authToken: string;

  beforeAll(async () => {
    authToken = await getTestToken();
  });

  describe("POST /api/v1/urls", () => {
    it("should create a shortened URL", async () => {
      // Test implementation
    });

    it("should handle invalid URLs", async () => {
      // Test implementation
    });

    it("should require authentication", async () => {
      // Test implementation
    });
  });

  describe("GET /api/v1/urls", () => {
    it("should return user's URLs", async () => {
      // Test implementation
    });

    it("should handle pagination", async () => {
      // Test implementation
    });
  });

  describe("POST /api/v1/urls/process-html", () => {
    it("should process HTML and replace links", async () => {
      // Test implementation
    });

    it("should handle invalid HTML", async () => {
      // Test implementation
    });
  });
}); src/tests/unit/services/UrlShortenerService.test.ts

// src/tests/unit/services/UrlShortenerService.test.ts

import { UrlShortenerService } from "../../../services/UrlShortenerService";
import { IUrlRepository } from "../../../interfaces/repositories/IUrlRepository";
import { ILoggingService } from "../../../interfaces/services/ILoggingService";

describe("UrlShortenerService", () => {
  let service: UrlShortenerService;
  let urlRepository: jest.Mocked<IUrlRepository>;
  let logger: jest.Mocked<ILoggingService>;

  beforeEach(() => {
    urlRepository = {
      findByOriginalUrl: jest.fn(),
      findByShortId: jest.fn(),
      create: jest.fn(),
      updateById: jest.fn(),
    };

    logger = {
      info: jest.fn(),
      error: jest.fn(),
      warn: jest.fn(),
      debug: jest.fn(),
    };

    service = new UrlShortenerService(urlRepository, logger);
  });

  describe("shortenUrl", () => {
    it("should create a new shortened URL", async () => {
      // Test implementation
    });

    it("should return existing URL if found", async () => {
      // Test implementation
    });

    it("should handle invalid URLs", async () => {
      // Test implementation
    });
  });

  describe("getOriginalUrl", () => {
    it("should return original URL from cache", async () => {
      // Test implementation
    });

    it("should return original URL from database", async () => {
      // Test implementation
    });

    it("should handle non-existent URLs", async () => {
      // Test implementation
    });
  });
}); src/models/ClickEvent.ts

// src/models/ClickEvent.ts

import mongoose, { Document, Schema } from "mongoose";

export interface ClickEvent extends Document {
  urlId: string;
  timestamp: Date;
  ipAddress: string;
  userAgent: string;
  referrer?: string;
  country?: string;
  city?: string;
  deviceType?: string;
  browser?: string;
  os?: string;
  emailClient?: string;
  campaignId?: string;
  source?: 'web' | 'email';
  metadata?: Record<string, any>;
}

const ClickEventSchema = new Schema<ClickEvent>(
  {
    urlId: {
      type: String,
      required: true,
      ref: "Url",
      index: true,
    },
    timestamp: {
      type: Date,
      default: Date.now,
      index: true,
    },
    ipAddress: {
      type: String,
      required: true,
    },
    userAgent: {
      type: String,
      required: true,
    },
    referrer: {
      type: String,
      default: null,
    },
    country: {
      type: String,
      default: null,
    },
    city: {
      type: String,
      default: null,
    },
    deviceType: {
      type: String,
      default: null,
    },
    browser: {
      type: String,
      default: null,
    },
    os: {
      type: String,
      default: null,
    },
    emailClient: {
      type: String,
      default: null,
    },
    campaignId: {
      type: String,
      default: null,
      index: true,
    },
    source: {
      type: String,
      enum: ['web', 'email'],
      default: 'web',
    },
    metadata: {
      type: Schema.Types.Mixed,
      default: {},
    },
  },
  { timestamps: true }
);

// Create compound indexes for common queries
ClickEventSchema.index({ urlId: 1, timestamp: -1 });
ClickEventSchema.index({ campaignId: 1, timestamp: -1 });
ClickEventSchema.index({ source: 1, timestamp: -1 });

export default mongoose.model<ClickEvent>("ClickEvent", ClickEventSchema);
src/models/User.ts

// src/models/User.ts

import mongoose, { Document, Schema } from "mongoose";
import bcrypt from "bcrypt";
import validator from "validator";

export interface IUser {
  email: string;
  name?: string;
  password: string;
  role: "user" | "admin";
  apiKey?: string;
  active: boolean;
  lastLogin?: Date;
  passwordChangedAt?: Date;
  createdAt: Date;
  updatedAt: Date;
}

export interface UserDocument extends IUser, Document {
  comparePassword(candidatePassword: string): Promise<boolean>;
  isModified(path: string): boolean;
  isNew: boolean;
}

// Export User type for backward compatibility
export type User = UserDocument;

const UserSchema = new Schema<UserDocument>(
  {
    email: {
      type: String,
      required: [true, "Email is required"],
      unique: true,
      trim: true,
      lowercase: true,
      validate: {
        validator: (value: string) => validator.isEmail(value),
        message: "Invalid email format",
      },
      index: true,
    },
    password: {
      type: String,
      required: [true, "Password is required"],
      minlength: [8, "Password must be at least 8 characters long"],
      validate: {
        validator: (value) => {
          // At least one uppercase, one lowercase, and one number (special characters optional)
          const passwordRegex = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,}$/;
          return passwordRegex.test(value);
        },
        message:
          "Password must contain at least one uppercase letter, one lowercase letter, and one number",
      },
    },
    name: {
      type: String,
      trim: true,
      maxlength: [50, "Name cannot be more than 50 characters"],
    },
    role: {
      type: String,
      enum: {
        values: ["admin", "user"],
        message: "{VALUE} is not a valid role",
      },
      default: "user",
    },
    apiKey: {
      type: String,
      unique: true,
      sparse: true,
      index: true,
    },
    active: {
      type: Boolean,
      default: true,
    },
    lastLogin: {
      type: Date,
    },
    passwordChangedAt: {
      type: Date,
    },
  },
  {
    timestamps: true,
    toJSON: {
      transform: function (doc, ret) {
        delete ret.password;
        delete ret.__v;
        return ret;
      },
    },
  }
);

// Hash password before saving
UserSchema.pre<UserDocument>("save", async function (next) {
  try {
    console.log("User model pre-save hook: Checking password modification");
    if (!this.isModified("password")) {
      console.log(
        "User model pre-save hook: Password not modified, skipping hash"
      );
      return next();
    }

    console.log(
      "User model pre-save hook: Generating salt and hashing password"
    );
    // Generate salt and hash password
    const salt = await bcrypt.genSalt(12);
    this.password = await bcrypt.hash(this.password, salt);

    // Update passwordChangedAt if password is modified
    if (this.isModified("password") && !this.isNew) {
      this.passwordChangedAt = new Date();
    }

    console.log("User model pre-save hook: Password hashed successfully");
    next();
  } catch (error) {
    console.error("User model pre-save hook error:", error);
    next(error instanceof Error ? error : new Error("Password hashing failed"));
  }
});

// Method to compare passwords
UserSchema.methods.comparePassword = async function (
  candidatePassword: string
): Promise<boolean> {
  try {
    return await bcrypt.compare(candidatePassword, this.password);
  } catch (error) {
    throw new Error("Password comparison failed");
  }
};

// Static method to find by API key
UserSchema.statics.findByApiKey = function (apiKey: string) {
  return this.findOne({ apiKey, active: true });
};

// Static method to find by email
UserSchema.statics.findByEmail = function (email: string) {
  return this.findOne({ email, active: true });
};

export default mongoose.model<UserDocument>("User", UserSchema);
src/models/Url.ts

// src/models/Url.ts

import mongoose, { Document, Schema } from "mongoose";

export interface Url extends Document {
  originalUrl: string;
  shortId: string;
  customSlug?: string;
  createdAt: Date;
  expiresAt?: Date;
  clicks: number;
  isActive: boolean;
  creator?: string;
}

const UrlSchema = new Schema<Url>(
  {
    originalUrl: {
      type: String,
      required: true,
      trim: true,
    },
    shortId: {
      type: String,
      required: true,
      // unique: true,
      trim: true,
    },
    customSlug: {
      type: String,
      uniqe: true,
      sparse: true,
      trim: true,
    },
    createdAt: {
      type: Date,
      default: Date.now,
    },
    expiresAt: {
      type: Date,
      default: null,
    },
    clicks: {
      type: Number,
      default: 0,
    },
    isActive: {
      type: Boolean,
      default: true,
    },
    creator: {
      type: String,
      default: null,
    },
  },
  { timestamps: true }
);

// Create indexes for faster queries
UrlSchema.index({ shortId: 1 });
UrlSchema.index({ originalUrl: 1 });

export default mongoose.model<Url>("Url", UrlSchema);
